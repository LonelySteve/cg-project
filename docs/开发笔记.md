# 开发笔记

## 目标

实现一个用以演示不同绘图算法的画板

## 使用技术栈

- TypeScript
- react
- Material-UI

## 需求分析

- 应用栏：用来展示项目名（仅此而已，没啥用）
- 属性面板
  - 当前元素名称下拉菜单：元素名称是唯一的，用户可以无法更改，输入一个不存在的名称会导致切换至未选中元素的状态
  - 操作按钮组
    - “新增”按钮：以当前选项添加一个指定元素到画板，只有当前处于未选中元素状态时才显示
    - “删除”按钮：从当前画板中移除该元素，只有当前处于选中元素状态时才显示
  - 指定当前绘制元素类型的下拉菜单
    - 线
    - 椭圆/圆
    - 图片
    - 文字
  - 当前层次：当未选中元素时，总是 -1 （表示即将处于最后一个），输入一个不合理的值会修正至最接近的限值
  - 颜色选取按钮组（边框颜色，填充颜色）：弹出颜色选取窗口，供用户改变当前所选取的颜色
  - 当前绘制元素参数选项组（内容受当前所选择的绘制元素类型影响）
    - 提供来源选项下拉菜单
      - 在画板中通过鼠标操作以确定参数
      - 手动输入（默认）
    - 参数
      - 线：起始点 终止点 线宽 RotaryInfo Rect
      - 椭圆/圆：原点 半径 RotaryInfo Rect
      - 图片：图片源 尺寸 RotaryInfo Rect
      - 文字：内容 字体 尺寸 RotaryInfo Rect
  - 指定当前绘图算法的下拉菜单（内容受当前所选择的绘制元素类型影响）
    - 线：内置 DDA Bresenham
    - 椭圆/圆：内置
    - 图片：内置
    - 文字：内置
  - 绘图算法参数选项组（内容受当前所选择的绘图算法影响）
    - DDA: 取整
    - 内置: 抗锯齿

- 画板面板
  - 鼠标指针如果移动到一个元素上，则切换样式到手型
  - 选中一个元素触发前提：
    - 在一个元素上左击或右击
    - 在属性面板的“当前元素名称下拉菜单”中选中一个元素
  - 取消选中状态触发前提：
    - 在画板的任何空白部分左击或右击
  - 选中某个元素能使属性面板显示该元素的选项及参数
  - 在“提供来源选项下拉菜单”选项为“在画板中通过鼠标操作以确定参数”的前提下，选中元素并拖动鼠标则能使该元素发生位移，并能属性面板中实时看到参数变化
  - 右键菜单
    - 如果在一个元素上
      - 拷贝当前元素
      - 置于顶层
      - 置于底层
      - 删除
      - 切换绘图算法（含动态子菜单，内容受当前所选择的绘制元素影响）
    - 一般情况
      - 新增一个元素
      - 清空
      - 保存到本地
  - 按下 X 键打开悬浮放大镜（有点难）

### 补充描述

- 当属性面板中的任何一个参数发生改变，绑定的画板上的元素会随之更新
- Rect: 一种描述绘制区域的结构，由左上角坐标和宽高组成，我们并不希望重绘发生时更新整个画板的像素，这样会导致性能下降，根据这个参数可以进行局部重绘操作
- RotaryInfo: 一种描述旋转信息的结构，由中心点坐标和旋转角度组成（规定顺时针为正）

### 问题分解

- 如何定义一个足够灵活的画板，该画板需要支持多种元素的绘制，并且元素的绘制方案及参数是可动态调节的？
  - 显然画板需要有一个用来存放元素对象的动态数组，绘制过程就是遍历这个数组，将每个元素依次绘制到画板中这样一个过程
  - 每个元素对象都保存有必要的基础参数，如Line的元素对象就应当有起始点和终止点等这样的属性
  - 绘制每个元素时，涉及到相应的绘制算法和参数（绘制算法也是有参数的，比如DDA算法的取整问题），如何得知某种元素支持的绘制算法？如何得知某种绘制算法需要哪些参数？如何将算法所需的参数选项渲染到界面中？
    - ~~使用装饰器特性收集可用的算法集合~~【未验证可行】
    - 在一个模块中定义一个元素与支持的算法关系的映射对象，外部模块通过此模块提供的一个函数来查询某种元素对应支持的算法集合，这里的算法集合中的元素到底是字符串标识还是类呢？
      - 是类，不过在ts中是一种构造函数，它对应了传入的元素所支持的所有算法类
    - 渲染过程由一个专门的组件提供，它接受一个具有特定静态成员的算法类，这个静态成员指出了此组件应该渲染什么东西，那么对于不同的元素如何确保同一个算法类的静态成员渲染的是正确的？
- 如何保证用户能在不阅读操作文档的前提下，自行探索出本Web界面提供的绝大数功能？

### 初步设计

#### 模块划分

- CanvasDrawer.tsx
  - 定义画板绘图相关的一系列类
    - `interface Drawable` 可执行绘制操作
    - `interface DrawLineable extends Drawable`
      - `public drawLine(line:Line)` 画线
      - `public drawLine(startPoint:Point, endPoint:Point, lineWidth?:number)` 画线
    - `interface DrawImageable extends Drawable`
      - `public drawImage(src:string, size?:Size, dPoint?:Point)` 画图
    - `class DrawerBase`
      - `static arithmeticType:ArithmeticType=ArithmeticType.unknown` 定义使用的算法名
      - `new (name:string, ctx:CanvasRenderingContext2D)` 构造函数
      - `public static readonly SupportedElement:Set<ElementType>` 表明支持的元素类型
      - `protected setBrushColor(color:Color)` 设置笔刷颜色
      - `protected setPenWidth(width:number)` 设置笔宽
      - `protected setPoints(point:Point[], color?:Color[], dPoint?:Point)` 
         将指定点数组以指定颜色数组绘制到画布的指定偏移点上，绘制颜色和偏移点是可选的
         当点数组和颜色数组长度不对等的时候，有以下三种情况：
           - 颜色数组长度为0：取当前对象所选的颜色
           - 颜色数组长度短于点数组：当颜色数组的颜色依次应用到绘制点后，剩余的绘制点沿用最后一个有效颜色
           - 颜色数组长度长于点数组：舍弃多余的颜色
    - `class BuiltInDrawer extends DrawerBase, DrawLineable, DrawImageable` 使用内置方法实现的Drawer
      - `static arithmeticType:ArithmeticType="内置"` 定义使用的算法名
    - `class DDALineDrawer extends DrawerBase, DrawLineable`
  - 基类拥有所有元素的绘制实现方法
  - `function drawerFactory(ctx:CanvasRenderingContext2D, elementType:ElementType, arithmeticType:ArithmeticType):Drawable` 拥有用于生产 Drawer 的工厂函数
  - `function registerDrawer(drawer:DrawerBase)` 注册 Drawer
    - `function ` 依赖于：确定某个元素可用的 Drawer 的函数


class Line extends CanvasElement{
  public ILineDrawer drawer; // 使用的绘制算法，和MFC的Drawing不同，这里使用的是组合方案，而非继承
  // ...
}

Line.drawer.drawTo(ctx:CanvasRenderingContext2D);
// 缩写
Line.drawTo(ctx:CanvasRenderingContext2D);

interface IDrawer{
  new();
  drawTo(ctx:CanvasRenderingContext2D);
}

interface ILineDrawer extends IDrawer{
  // 定义构造函数
}
interface IImageDrawer extends IDrawer{
  // 定义构造函数
}

class DrawerFactory{
  ILineDrawer getLineDrawer(args:Args, algorithmType:AlgorithmType);
  IImageDrawer getImageDrawer(args:Args, algorithmType:AlgorithmType);
  IDrawer getDrawer(element:ElememtType, args:Args, algorithmType:AlgorithmType);
}

class DDADrawer extends ILineDrawer;
class BresenhamBaseDrawer;
class BresenhamLineDrawer extends BresenhamBaseDrawer,ILineDrawer;

class DDAArgs extends Args;

